https://www.acmicpc.net/problem/10844
```C++
#include <iostream>
#define mod 1000000000

using namespace std;

int dp[101][10]{};

int main()
{
	int n{};
	cin >> n;

	for (int i = 1; i < 10; i++)
		dp[1][i] = 1;

	for (int i = 2; i <= n; i++)
	{
		for (int j = 0; j < 10; j++)
		{
			if (j == 0)
				dp[i][0] = dp[i - 1][j + 1];
			else if (j == 9)
				dp[i][9] = dp[i - 1][j - 1];
			else
				dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];

			dp[i][j] %= mod;
		}
	}

	int result{};

	for (int i = 0; i < 10; i++)
		result = (result + dp[n][i]) % mod;

	result %= mod;

	cout << result << endl;
}
```
- dp를 이용해 푸는 문제로 점화식을 잘 생각해보면 된다
- 일단 dp의 첫번째 배열의 index는 몇개의 숫자를 사용할지, 두번째 배열의 index에는 첫번째 배열에 저장된 숫자의 갯수를 사용했을 때 현재 index의 숫자가 뒤에 왔을 때 갖을 수 있는 경우의 수를 저장한다
- 이때 dp의  첫번째 배열의 1번 index에는 모두 1의 경우만 가능 할 것이므로 i=1부터 10보다 작을 때까지 dp의 1번 배열의 값들을 1로 넣어준다
- 이제 이중 for문을 이용하여 값을 넣어줄 것인데, 이때 점화식을 구해야 한다
- 예를 들어 2,1번이라 해보자
- 숫자는 2개이고 1이 앞으로 왔을 때 연속되는 수의 경우의 수는 01, 21일 것이다
- 하지만  0이 앞에 나올 수 없으므로 dp의 2의 1에는 1이 저장 될 것이다
- 다른 예로 들어 2,2라고 해보자
- 경우의 수는 12,32 두가지가 나올 것이다
- 이를 통해 점화식을 구하면 dp의 i번째 j에는 dp의 i-1의 j-1 + dp의 i-1의 j+1의 값이 들어갈 것이다
- 다시 점화식을 써보면 dp{i}{j} = dp{i-1}{j-1} + dp{i-1}{j+1} 일것이다
- 하지만 j가 0,과 9는 각각 그 이하나 그  이상의 수가 없으므로 예외처리를 해줘야 한다
- dp{i}{0}에는 dp{i-1}{j+1}을 dp{i}{9}에는 dp{i-1}{j-1}을 넣어주면 된다
- 이때 dp{i}{j}의 값을 1,000,000,000으로 나눠준 나머지 값을 저장해 줄것이다 그 이유는 문제에 1,000,000,000으로 나눈 나머자 값을 출력하라 했기 때문이다
- 이제 첫번째 배열에 n이 들어간 값들을 모두 더해줘야 한다
- 더할 때 마다 1,000,000,000을 나눠준  값을 result에 더해주어 연산해주면 된다