- 정의
	- 문제를 해결하기 위해 문제를 작은 하위 문제로 나누고, 그 결과를 저장하여 동일한 하위 문제를 반복해서 풀지 않도록 하는 알고리즘 기법
- 조건
	- 참조투명성을 가져야한다
		- 입력을 제외한 외적 요소에 결과 값이 영향을 미치지 않고 동일한 입력에 대한 동일한 출력을 가지는 것을 의미
		- ex) int Add(int a, int b){return a+b;}// 참조 투명성 가짐
		- ex)int c; int Add(int a, int b){return c+a+b;}// 참조 투명성 갖지 않틈
	- Optimal Substructure(최적 부분 구조)
		- 문제를 해결할 때 하위 문제들을 해결한 결과를 이용해 전체 문제의 최적 해답을 구성할 수 있는 구조
		- ex) 피보나치 수열을 구할 때 F(n) = F(n-1)+F(n-2)와 같이 작은 하위 문제들을 이용해 전체 문제를 해결할 수 있는 경우
	- Optimal Substructure(겹치는 부분 문제)
		- 동일한 하위 문제가 여러번 반복해서 등장하는 경우, 이러한 문제의 해를 저장해 두고 재사용할 수 있는 구조를 가져야함
	- DAG구조(Directed Acyclic Grap)
		- 방향성이 있고 사이클이 없는 그래프 구조
		- 사이클이 있으면 사이클을 해제하고 DAG를 통해 풀지만 코태에서는 안나온다
- Tip
	- 1번은 보통 충족하지만 2,3번을 판단해야된다
	- 이때 코태에선 판단할 시간이 부족하다
	- 따라서 <font color="#ffff00">완전탐색이 가능한지 판단</font>, <font color="#ffff00">메모이제이션 판단</font>(이때 메모이제이션을 담은 배열의 크기가 너무 크다면 DP나 다른 알고리즘을 활용해야함)
- DP란?
	- 사실 점화식을 만들고 거기에 코드를 맞춰 구축해야한다
	- 완전탐색을 풀듯이 모든 경우의 수를 생각하고 그 경우의 수를 메모이제이션을 하는 것이다
	- 메모이제이션?
		- 어떤 상태 값을 자료구조에 저장하는 것
		- map이든 set이든 array든 계산된 값을 저장해 놓고 다시 계산하는 것을 방지하는 것

