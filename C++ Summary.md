- 변수
    
    - 지역,전역,동적
        - 지역
            - stack에 저장되며 블록({})으로 쌓인 부분은 전부 지역변수 이다
        - 전역
            - Data구역에 저장되며 클레스 외부에 선언된 변수
            - static
            - extern: 다른 파일에 있는 변수를 전역으로 쓰기 위한 키워드
        - 동적:
            - Heap구역에 저장되며 new, malloc
            - new VS malloc
                - new
                    - 생성자를 호출
                    - 클레스 크기 단위의 할당
                - malloc
                    - byte단위의 할당
    - 메모리 구조
    
    ![](https://blog.kakaocdn.net/dn/cdomiu/btstRts6SfG/LKJtEt3FQ5kJu41tIOScTK/img.png)
    
    - Data
        - 공용영역
    - heap과 stack이 만나서 어느 하나가 넘어가면 스텍 오버플로우, 지워진 주소를 또 지우려 하면 언더플로우가 발생된다
    
     
    
- static(지역, 맴버)
    - 지역변수 일땐 최초 호출 시점(할당 될때)에서 생성이 된다
    - 맴버 변수는 컴파일이 완료 되었을 때 생성된다(프로그램 실행시라고 봐도 무방하다)
- extern
    - 외부에 있는 파일에 변수를 extern키워드를 사용해서 현재 파일에서 사용하게 해주는 키워드로 전역변수라 보면 된다
- Call By Value/Address/Referne
    - 값에의한 호출/주소에의한 호출/참조에의한 호출
- auto
    - 장점은 자료형을 우리가 원하는 자료형으로 실시간 맵핑이 가능하다
    - 단 해당 자료형이 미리 컴파일 되어있다는 전제하에 맵핑이 가능
    - 단점은 멀티 컴파일시 즉 미리 컴파일이 되어있지 않았을 때 오류가 생긴다
        - 예를들어 A클래스에서 B클래서의 맴버로 auto키워드를 썻을 때 B가 컴파일이 되지 않은 상황에서 오류가 생긴다 일반적으로는 include가 있으면 include를 먼저 컴파일하기 때문에 auto가 문제가 되지 않지만 멀티 컴파일에선 그렇지 않기 때문에 문제가 생긴다
- 상수(const)
    - 포인터
        - 같은 의미로 값을 변경할 수 없다
        ```C++
	    const int a = 1;
	    int const b = 2;
        a = 3;//Error  
        ```
        - *c = 3, *d = 2처럼 저장되어 있는 공간에 접근해 직접적으로 값을 변경 불가하나 c,d의 주소값은 변경이 가능
        ```C++
        int data = 3;
        const int* c = &data;
        int const* d = &data;
        c = &a;
        d = &a;
        *c = 2;//error
        ```
        - e 자기 자신의 주소를 변경 불가
        ```C++
        int* const e = &data;
        *e = 3;
        e = &a;//error
        ```
        - 해당 함수에 내에 맴버 변수 변경 불가 및 COnst 함수만 호출 가능
        ```C++
		int Add()const;   
		```
    - 레퍼런스
        - 포인터와 동일하나 기호만 &로 바뀜
        - 주소 참조는 의미가 없으므로 값 참조만 막는다
    - 맴버
        - 함수나 클레스 내부에 선언된 변수
- 매크로
    - 변수의 문제점
        - 자료형(type) 확정이 안되어있어 정확한 값을 사용할 수 없다
    - #define Add(a,b)a*b
        - 코드 치환이 그대로 일어나 a+bab가 되어 연산자 우선순위가 이상하게 변한다 따라서 중간에 괄호를 써서 사용한다(a+b)(ab)
- 구조체
    
    - 패딩
        - 바이트를 일정한 간격으로 끊기 위해 사용
        - CPU의 공간을 희생해 속도를 올림
        - 데이터 소모량을 최소화 시켜주기 위해 사용한다
    - 공용체(union)
    
    ![](https://blog.kakaocdn.net/dn/dZoBwa/btstSzsUqPZ/XobzaZhed8T8gTOwYMIHHk/img.png)
    
    - 공용체 안에 있는 서로 다른 변수들을 같은 주소로 사용하기 위해 사용한다
    - ex)struct안에 float _11의 주소와 m[0][0]의 주소가 같다
    - 구조체와 같지만 모든 맴버 변수가 하나의 메모리 공간을 공유한다는 점이 추가된다
    - 따라서 모든 맴버 변수가 같은 메모리를 공유하므로 공용체는 한번에 하나의 맴버 변수만 사용이 가능하다
    
- 동적할당
    - malloc,free
        - 라이브러리 제공 함수로 라이브러리가 필요하다
        - byte단위 사이즈를 매개변수로 받고, 리턴 값이 void*형으로 sizof()와 캐스팅을 활용해야 함
        - 함수로 할당한 메모리는 realloc 으로 크기를 바꿔 재 할당이 가능
    - new, delete
        - 기본 제공 키워드로 별도 라이브러리가 없어도 된다
        - 할당 타입을 지정하면 알아서 할당할 타입의 포인터로 넘어오기 때문에 할당할 타입과 같은 타입의 포인터 변수로 받으면 된다
        - 생성자를 자동 호출해준다
        - 재 할당 기능이 없어 새로 할당하여 복사하고 원래 메모리를 해제를 해야함
    - virtualalloc-virtualfree
        - 가상 메모리를 할당하고 해제한다
        - 공간을 미리 예약이 가능하다
        - 물리적인 메모리를 소비하지 않으면서 주소 공간만을 미리 할당해 놓는 방법이다
        - 언제든지 필요한 부분만 확정해 사용이 가능하다
        - 할당한 메모리의 엑세스 권한을 지정할 수 있어 malloc과 다르게 할당한 메모리는 읽기전용, 엑세스 금지 속성을 가지며 실수로 인한 데이터 파괴를 막는다
        - Reserve
            - 미리 예약한 메모리를 잠금으로써 다른 것들이 들어오지 못하게 방어하는 역할
- 함수 호출 규약:
    - 스택 프레임
        
        - 함수를 선언할 때 만들어지는 공간을 스택 공간이라한다
        
        ![](https://blog.kakaocdn.net/dn/nGeOl/btstNATFoHr/CiENZFxcXVDLNOMc0SKLFK/img.png)
        
        - 메모리 오버플러우
            - 할당된 버퍼들이 정의된 버퍼의 한계치를 넘는 경우
            - 복귀 주소를 변경하여 임의 코드를 수행하는 경우
        
    - EBP, ESP
        - EBP(Extended Base Pointer)
            - 현재 스택에 가장 바닥을 가르키는 포인터
            - 새로운 함수가 호출될 때마다 EBP 레지스터 값이 지금 사용했던 스택 꼭대기의 위에 위치하고 새로운 Stack이 시작
            - EBP는 새로운 함수가 호출이거나 현재 실행중인 함수가 종료되어 리턴될 때 값이 달라짐
            - 스택 프레임이 생길 때 베이스 포인터
        - ESP(Extended Stack Pointer)
            - 현재 스택 프레임을 가르키고 있는 스택 포인터
            - ESP는 다음번 Data를 Push 할 위치가 아니라 다음에 POP했을 때 뽑아낼 데이터의 위치를 가르 킴
        - EBP와 ESP가 같아지는 순간 스택의 파괴가 일어난다
    - cdecl, stdcall, thiscall, fastcall
        - cdecl, stdclall 정도만 알면 됨
        - cdecl
            - 전달 인자는 오른쪽에서 왼쪽으로 전달된다
            - cdecl방식은 caller에서 전달 인자에 대한 Stack을 정리한다(함수 외부)
            - 호출한 함수에서 스택 제거
            - 가변 함수를 사용할 수 있다
        - stdcall
            - 전달 인자는 오른쪽에서 왼쪽으로 전달된다
            - stdcall 방식은 callee에서 전달 인자에 대한 Stack을 정리한다(함수 내부)
            - 호출 받은 함수에서 스택 제거
        - fastcall
            - 전달 인자는 처음 두개는 ECX,EDX 레지스터에 직접 넣고 나머지에 대해선 오른쪽에서 왼쪽으로 전달된다
            - fastcall은 레지스터를 직접 이용하기 때문에 속도가 빠르다
            - fastcall 방식은 callee에서 전달 인자에 대한 Stack을 정리한다(함수내부)
        - thiscall
            - 클래스 맴버 함수에서 정의할 수 있는 규약이며, 매개변수들을 스택으로 저장하지만 그것을 this 포인터로 연결하는 형식이다
            - this 포인터는 레지스터에 저장된다
            - 무조건 포인터만 레지스터로 저장되며 _thiscall을 명시하지 않은 경우 매개변수들은 _cdecl로 들어간다 _stdcall은 무시하며, _fastcall, _vectorcall시 2개만 레지스터에 저장하듯 레지스터에 저장되는 포인터를 포함하여 하나의 매개변수를 추가로 저장한 뒤 나머지 인자들은 모두 스텍에 저장한다
    - 가변파라미터 함수 구현 방법(찾아보기)
        - 가변파라미터(가변인자): 인자의 개수가 정해지지 않았을 때 사용하는 것
        - <stdarg.h> 가변인자들을 제어하기 위한 라이브러리 헤더 파일
            - va_list : 가변 인자 목록으로 가변 인자의 메모리 주소를 저장하는 포인터
            - va_start : 가변 인자를 가져올 수 있도록 설정
            - va_arg : 가변 인자 포인터에서 특정 자료형의 크기만큼 값을 꺼냄
            - va_end : 가변 인자 처리가 끝났을 때 포인터를 NULL로 초기화해준다.
        - 주의사항
            - 가변 인수를 사용하기 위해서는 가변 인수의 갯수를 알수 있어야 하기 때문에 반드시 하나 이상의 고정 인자가 필요하다.
                - 가변인수의 크기를 알아야만 함수에서 정확한 제어가 가능하기 때문
                - 고정 인자를 통해 함수 내에서 크기를 유추하게 구현 또한 가능하다.
                    - printf 같은 경우 서식 지정자의 개수를 카운팅해 구현
            - 가변 인수는 항상 함수의 가장 뒤에 호출이 돼야 된다.
                - 당연히 고정 인자와 가변 인자를 구분하기 위해서는 가변 인자는 뒤에 있어야 된다.
                    - 만약 앞쪽에 위치하고 있다면 가변 인자의 끝을 알 수 없다.
            - 가변 인수의 자료형을 명확하게 알아야 한다.
                - va_arg를 통해 가변 인자를 담은 목록에서 자료형의 크기만큼 빼내어 데이터를 처리하기 대문에 데이터의 타입을 유추할 수 있어야만 정확한 가변 인자들의 값을 확인할 수 있다.
- 컴파일러
    - 컴파일 과정
        - 전처리기(.h)
            - 헤더랑 #붙어있는것, 전역변수를 처리함
        - 컴파일(.cpp)
            - 컴파일러
        - object(동적파일)
        - Linker(.lnk)
            - object 파일과 라이브러리들을 lnk파일로 만들어줌
        - .exe(object+.lnk가 합쳐진 애)
    - 언리얼 컴파일 과정(찾아보기)
        - 언리얼 헤더 툴
        - 컴파일러(.cpp)
        - 빌드(.dll)
        - .exe
    - 컴파일러와 인터프리터 차이
        - 프로그래밍 언어를 기계어로 변환해주는 애들
        - 컴파일
            - 프로그래밍 언어로 쓰여있는 소스 코드를 다른 언어로 변환하고 그 결과를 목적 파일에 써놓는 프로그램
            - 소스를 한번에 기계어로 변환시킴
            - 개발의 편의성은 떨어지지만 실행 속도가 빠르다
            - 컴파일을 한번에 하기 때문에 컴파일 시간이 오래 걸리지만 이미 기계어로 변환된 목적 파일을 실행하면 되므로 속도가 빠르다
            - 단점은 컴파일 후 에러를 알려주므로 수정이 용이하지 않다
        - 인터프리터
            - 실행 전 기계어로 컴파일 과정을 거치지 않고 소스코드를 바로 실행하는 진행 환경
            - 내부적으로 소스 코드를 기계어가 이해할 수 있는 형태로 변환되어야 하지만 컴파일러와 다르게 소스를 한번에 기계어로 변환시키는 것이 아닌 코드를 한줄씩 읽어 기계어로 변환해 임시로 저장하고, 변환하는 것을 바로 실행시킴
            - 기계어로 변환된 코드를 실행파일로 작성하지 않고 Memory에 바로 로드 시켜 실행
            - 개발의 편의성이 높지만 변환과 실행을 동시에 진행하므로 속도가 느리다
            - 소스코드 한줄을 변환해 실행하기 때문에 실행 시작 시간은 빠르지만 실행 속도는 느리다
            - 코드를 한 줄씩 실행하므로 에러를 바로 알려줘 실시간으로 코드 수정이 가능하다
    - C#과 C++차이
        - c++은 모든 권한은 개발자한태 줄태니 책임도 개발자가 지고 c#은 자기가 모든걸 처리할태니 필요한것만 집중하도록 설계되어있다
        - 공통점
            - 객체지향 언어
            - 컴파일러 언어
        - 차이점
            - 바이너리 크기
                - C#은 컴파일을 하면 수많은 오버헤드와 라이브러리가 함께 포함된다 그에 비해 C++은 훨씬 가볍다 그래서 컴파일을 하면 C#의 크기가 훨씬 더 커진다
            - 성능
                - C++은 고급 언어들이 효율적이지 않은 경우에 사용한다
                - C++은 성능이 중요한 어플리케이션에 작성된다
                - C#은 일반적인 워드 프로세서와 같은 성능에 크게 문제가 발생하지 않는 어플리케이션을 만드는데 사용한다
            - 가비지 컬렉션
                - 가비지 컬렉션이란 시스템에서 낭비되는 메모리 자원을 회수하는 작업
                - C#은 크게 신셩쓰지 않아도 됨
                - C++은 자동적으로 수행되지 않기 때문에 객체가 사용하는 메모리를 직접 할당하고 해재해 주어야 한다
            - 타깃 플레폼
                - C#은 마이크로소프트가 다른 플렛폼에서도사용할 수 있게 노력하지만 주로 윈도우 운영체제를 겨냥해서 ㅁ나들어진다
                - C++을 사용하면 맥, 윈도우, 리눅스등 어떤 플랫폼에서도 구동할 수 있다
            - 프로젝트 유형
                - C++은 하드웨어를 직접 제어하는 어플리케이션이나 뛰어난 성능이 필요한 작업을 한다. 서버,네트워킹, 게임, 장치드라이버에 사용한다
                - C#은 일반적인 웹, 모바일, 데그크톱 어플리케이션에 사용한다
            - 컴파일러 경고
                - C++은 문법적으로 틀리지만 않으면 거의 모든 작업을 수행할 수 있다 그래서 유연성을 가진 언어이지만 컴퓨터에서 실제로 피해를 일으킬 수도 있다
                - C#은 훨씬 더 보호체계를 잘 작추고 있어서, C++에서라면 허용될 수도 있는 심각한 에러들을 허용하지 않고, 컴파일러가 에러를 표시해서 경고를 해줍니다
    - 게임 프로그래밍에서 C++사용 이유
        - 메모리 관리에 탁월하여 게임 리소스에 대한 더 많은 제어, 유연성 및 최적화를 제공한다
        - 다른 고급 언어보다 더 나은 런타임 성능을 제공한다
- 정수, 실수
    - Float형의 오차 발생 이유와 범위
        - 정해진 바이트 안에 소수점을 쪼개넣다보니 발생한다
        - 범위는 소수점 8번째 자리부터 발생한다
    - Int, Float의 값 문자열로 변경
        - int→문자열int main() { int number = 12345; std::string strNumber = std::to_string(number); std::cout << "Converted string: " << strNumber << std::endl; return 0; }
        - #include <iostream> #include <string>
        - float→문자열int main() { float number = 3.14f; std::string strNumber = std::to_string(number); std::cout << "Converted string: " << strNumber << std::endl; return 0; }
        - #include <iostream> #include <string>
    - 문자열을 int, float값으로 변경
        - 문자열→intint main() { std::string strNumber = "12345"; int number = std::stoi(strNumber); std::cout << "Converted int: " << number << std::endl; return 0; }
        - #include <iostream> #include <string>
        - 문자열→floatint main() { std::string strNumber = "3.14"; float number = std::stof(strNumber); std::cout << "Converted float: " << number << std::endl; return 0; }
        - #include <iostream> #include <string>
- 포인터
    - 허상 포인터(Dangling Pointer)
        - 프로그램에서 더이상 유요하지 않는 메모리 주소를 가르키는 포인터
        - 발생이유
            - 참조된 주소가 지워졌거나 dynamicCasting이 실패했을 때(부모 크기는 알지만 자식 크기를 모를경우)
    - 함수 포인터
        
        - 함수를 가르키는 포인터를 의미하며 함수의 주소를 가진 변수로, 해당 함수를 호출하거나 참조할 수 있는 기능을 제공한다
        - 사용 이유
            - 결합도를 낮추기 위해서 사용한다
        - 델리게이션(Delegation)
            - 함수 포인트를 기반으로 만들어 언리얼 기준으로 함수 포인트를 직렬화한다거나 1대n의 기능을 추가한다거나 함수 포인트들의 관리를 포함한것이다
            - 특정 기능을 다른 객체에게 위임하고, 그에 따라 필요한 시점에서 메소드의 호출만 받는것
            - 델리게이션과 함수포인터의 차이
                - 함수포인터는 1:1대응이지만 델리게이션은 1대 n으로 대응이 가능하다
        - CallBack함수
        
        ![](https://blog.kakaocdn.net/dn/bdshwu/btstX1u9MWg/UWKVNDgIyMrupDY9KB6PiK/img.png)
        
        - 함수를 등록해놓고 특정 상황마다 콜해주는 함수로 현재 객체(함수)를 다른 놈한태 주고 그때마다 나 자신의 함수를 콜해주는 것
        - 동적 함수 선택
            - 실행중에 여러 함수중 하나를 선택해 호출할 때, 함수포인터를 사용하여 선택된 함수를 가리키고 호출할 수 있다
            - 프로그램의 흐름을 동적으로 제어하는데 유용하다
        - 다향성 구현
            - 함수 포인터를 사용해 가상함수테이블과 같은 메커니즘을 구현할 수 있다
            - 객체지향 프로그래밍에서 다얗성을 지원하는 기능을 구현하는데 사용된다
        
- Template  ![](https://blog.kakaocdn.net/dn/bsNbWy/btstNBZpzdI/i1esjkqPyT3NyYovnDMqtk/img.png)
    
    - 사용 이유
        - 자료형 타입을 특정할 수 없을 때 사용한다
    - 정의 
        - 템플릿 매개변수를 상용하여 일반화되는 타입이나 값을 나타낸다
        - 클래스템플릿의 템플릿 매개변수는 클래스의 매개변수나 맴버함수의 타입으로 사용이 가능하다
        - 함수템플릿의 템플릿 매개변수는 함수의 매개변수 타입이나 반환 타입으로 사용될 수 있다
    - 특징
        - cpp에 정의할 수 없어 .h에 몰아서 해야한다
    - 동작 방식
        
        - 컴파일시 자료형을 맵핑한다
        - 템플릿 인스턴스화
        - 템플릿 기반으로 실제 타입 또는 값에대한 인스턴스를 생성하는 과정을 템플릿 인스턴스화라고 한다
        - 클래스 템플릿의 경우 템플릿 인수를 지정하여 클래스의 실제 타입을 결정한다
        - 함수 템플릿은 템플릿 인수를 지정해 함수의 매개변수 타입이나 반환 타입을 결정한다
        - 코드의 재사용성과 일반화를 가능하게 해준다
        - 타입을 특정화 할 수 없을 때 사용한다
        
    - 특수화
        - 특정 자료형에 대해서는 템플릿화 하지 않겠다는 것
    - 함수 템플릿 
        
        - 정의   
            - 일반적인 형태의 함수를 정의하는 템플릿
            - 템플릿 매개변수를 사용하여 함수의 매개변수 타입이나 변환 탕비을 일반화 할 수 있다
            - 특정 타입에 대한 함수를 작성하는 것이 아닌 템플릿 기반으로 한 여러타입의 함수를 자동으로 생성할 수 있다
        
    - 클래스 템플릿 
        
        ![](https://blog.kakaocdn.net/dn/FMsF2/btst5mnJWuy/1KkKxzUqbKaTkbQ22Jp4YK/img.png)
        
        - 정의
            - 일반적인 형태의 클래스를 정의하는 템플릿
            - 템플릿 매개변수를 사용해 클래스의 맴버변수 또는 맴버 함수의 타입을 일반화 할 수 있다
            - 특정 타입에 대한 클래스 인스턴스를 생성하는 것이 아닌 템플릿 기반으로 한 여러 타입의 클래스를 생성할 수 있다
        - 사용 이유
            - static등 부모서 상속이 되지 않는 요소들을 자식에서 다루기 위해서 사용한다
        - 상속관계
            - static처럼 상속되지 않는 요소들을 자식에서 자기 자신을 자료형으로 맵핑해서 사용하기 위해 사용한다
    - inline 함
    - ![](https://blog.kakaocdn.net/dn/cbqb7V/btstNyBB7MQ/gX9YYpjk9MTh3YlMfjax3K/img.png)  
        - 정의
            - 점프할 내용을 컴파일러가 미리 복사해놓은 함수로 헤더에 정의한다, template도 inline함수라 봐도 된다
            - 함수가 인라인화 될지 안될지 모르는 경우 언리얼에서 강제로 인라인시키기 위해 FORCEINLINE을 사용한다
        - 동작 방법 
            - 일반적인 함수는 호출 과정을 거치는데 인라인 함수는 호출 과정을 거치지 않고 함수의 모든 코드를 호출된 자리에 바로 삽입하는 방식의 함수이다
            - 함수 호출로 인한 오버헤드를 줄일 수 있으며, 함수가 짧은 경우 본문을 호출하는 것보다 함수를 인라인 하는것이 빠른 실행 속도를 가질 수 있다
            - 함수가 긴 경우 인라인화를 수행 할 경우 코드의 크기가 증가하여 캐시 효율성이 저하될 수 있다
            - 컴파일러에게 함수를 인라인화 할것을 요청하는 것이지 강제하는 것이 아니다
        - _inline
            - Microsoft Visual C++컴파일에서 사용된다
            - 일반적인 인라인 함수와 비슷하지만 이 함수를 사용하면 컴파일러에게 해당 함수를 인라인화하는 강제성을 부여한다
            - 해당 함수의 인라인화가 실패할 경우 일반함수로 전환되는 기능이 포함되어 있다
        - __inline
            - GCC컴파일러에 사용된다
            - 일반적인 인라인 함수와 비슷하지만 이 함수를 사용하면 컴파일러에게 해당 함수를 인라인화하는 강제성을 부여한다
            - 해당 함수가 반드시 인라인화되어야 함을 의미한다
    
- OOP
    - 특성
        - 정보은닉: 공개되지 않아야하는 내용을 숨겨주는것
        - 캡슐화:입/출력은 공개되어 있지만 구현자체를 외부에 공개하지 않는것
        - 상속성: 
            - 다운캐스팅 체크 방법
                - dynamicCast는 런타임에 탕비 검사를 수행하고, 올바른 다운 캐스팅인 경우에만 변환을 수행하므로 dynamic_cast연산자를 이용하여 체크를 하면 된다
        - 다형성
            - 오버로딩(overloading)
                - 같은 이름을 가진 함수나 연산자를 다른 매개변수 또는 인자 타입으로 여러번 정의하는것
                - 코드의 가동성을 높이고 코드의 재사용성을 높이는데 사용한다
            - 오버라이딩(overriding)
                - 기본 클래스에서 이미 정의된 가상 함수를 파생 클래스에서 재정의하는것
                - 상속관계에서 기본 클래스의 가상 함수를 파생 클래서에서 동일한 시그니처로 다시 정의하므로써, 파생 클래스의 객체에서 해당 함수가 호출될 때 재정의 된 동작이 수행된다
                - 다향성을 구현하소 동적으로 올바른 함수를 호출할 수 있다
        - 추상화:
            - 정의 
                - 부모를 정의하는 시점에서 자식으로 어떻게 변화될지 알수 없으므로 부모에선 선언만을 두는 것 즉 부모에 정의되어 있지 않은 부분을 자식에서 정의하는 것이다
                - 이를 순수가상함수로 구현할 수 있으며 이 함수가 포함되어 있으면 추상클래스라 한다
            - 특징
                - 객체화가 불가
        - 가상화
            - 부모에 이미 정의되어 있는 기능을 자식에서 재정의 하는것
- 클래스
    - 암시적 멤버 메서드 6가지
        - 기본생성자, 기본소멸자, 복사생성자, 대입연산자,이동생성자,이동대입연산자
    - 복사 / 이동의 차이
        - 복사생성자는 같은 클래스로 만든 객체에 있는 데이터를 복사하여 넘겨주는 것으로 객체를 전달하거나 반환하여도 기존의 객체에 있는 데이터는 유지된다
        - 아동생성자는 임시 객체나 이동 가능한 객체의 소유권을 이전하는데 사용하므로 복사생성자와 다르게 객체를 전달하거나 반환하면 기존 객체에 있는 데이터는 유지되지 않는다
        - l-value
            - 기존것을 유지 함
        - r-value
            - 기존것을 유지하지 않고 삭제함
        - vector의 push_back과 emplace_back의 차이
            - push_back은 생성자가 없이 복사생성자를 호출하지만 emplace_back은 호출하지 않는다
            - push_back은 기존 메모리를 유지하지만 emplace_back은 기존 메모리를 유지하지 않는다
    - 얕은/깊은 복사의 차이
        - 얕은복사
            - 객체나 데이터 구조의 주소를 복사하는 방법으로 원본 객체와 복사본 객체가 동일한 데이터를 사르키는 경우
            - 같은 데이터를 공유하므로 한쪽에서 데이터를 변경하면 다른쪽도 영향을 미칠수 있다
        - 깊은복사 
            - 깊은 복사의 구현은 대입연산자와 복사 생성자에서 해줘야한다
            - 객체나 데이터구조의 내용을 복사하는 방법으로 원본 객체의 데이터를 새로운 메모리 영역에 복하하여 복사본 객체를 생성한다
            - 독립적인 데이터를 가지므로 한 쪽에서 데이터가 변경이 되어도 다른쪽에 영향이 없다
        - 복사생성자 호출 조건
            - 같은 클래스에 객체로 초기화할 때
            - 함수의 파라미터로 CallByValue로 넘겨질 때, 리터턴받아올때 콜이된다
- 가상함수![](https://blog.kakaocdn.net/dn/beIsdX/btstRJpcD3j/3tfTNkqaNLkTUVCkUSEWY0/img.png)  
    - 가상화
        - 부모에서 정의된 내용을 자식에서 재정의 할 수 있도록 하는것
    - 조건
        - 부모에 가상함수가 하나라도 존재하며 동적으로 객체화가 됐을 때
        - 일반적으로 가상화가 될때 가상 소멸자를 만들어 부모에 있는 소멸자를 콜하게해준다
        - 위에 그림은 정적으로 객체화가 됐으므로 가상화가 되지 않는다
    - 가상함수 테이블
        - 부모클래스 영역에 항상 존재한다
        - 가상화 되어있는 함수의 주소를 찾기위한 테이블
        - B영역 안에있는 A영역 안에 가상테이블이 들어간다
    - 추상클래스
        - 객체화가 불가능하다
    - 인터페이스
        - 서로다른 객체들끼리 그룹으로 묶기위해 사용, 엄청 많이 사용
    - 가상소멸자
        - 일반 소멸자와 달리 부모의 소멸자도 콜이되는 소멸자이다
- RTTI
    - 실시간 런타임에서 자료형을 검사하는 것
    - type-id
        - 해당 타입에대한 해쉬 자료형
        - 리플렉션이 이를 이용하여 만든다
    - static/dynamic/const/reinterpreter![](https://blog.kakaocdn.net/dn/cxI1HD/btstXwCmSlr/OHkTds0L2T4wzCTHerN4x0/img.png)
        - 위의 casting차이
            - 둘다 static 정적 케스팅으로 둘다 컴파일시 체크를 한다
            - b=(float)a
                - c스타일 케스팅
                - 자유롭게 모든 케스팅이 가능하다
                - 현업에선 잘 사용하지 않는다
            - c=static_cast<float>(a)
                - C스타일 정적 케스팅
        - Static Cast
            - 정적으로 할당된 애들을 대상으로 casting을 하는것
            - 다른 애들과 달리 RTTI가 아니라 컴파일시 체크를 한다
            - 프로그래머가 형변환시 오류를 체크해준다
        - Dynamic Cast
            - 동적으로 할당된 애들을 대상으로 casting을 하는것
        - Const Cast
            - const를 깨주는 casting으로 절대절대 사용하면 안된다!!
        - Reinterpreter Cast
            - 주소를 강제 형변환 해주는 casting
            - 자료형이 틀려지면 뎅글링포인터가 발생한다
- SOLID
    - 단일책임(Single Responsibility Principle)
        - 클래스 하나는 자신의 역할만을 관리한다
        - 응집도를 높임
    - 계방폐쇄(Open/Closed Principle)
        - 확장에는 열려있고 변경에는 닫혀있어야한다
    - 리스코프 치환(Liskov Substiution Principle0
        - 자식클래스는 부모클래스의 자리에 대체가 가능하다 - 부모 클래스가 없어도 자식 클래스가 동작해야 한다는 뜻
        - 부모는 자식의 책임을 넘어서면 안되기 때문에 사용한다
    - 인터페이스 분리(Interface Segregation Principle)
        - 인터페이스를 통해 객체를 분리한다
        - 지나친 일반화(공통기능)를 없애겠다
        - 공통 기능이 한곳으로 몰리는 것을 방지
    - 의존관계역전(Dependency Inversion Principle)
        - 커플링(서로간의 참조)을 해제하기 위해 사용
        - 서로간의 참조하는 것을 끊는다
        - 의존성방향이 있을 때 인터페이스를 중간에 둬서 커플링을 깨줌
- Lamda
    - 익명메서드
        - 이름이 없이 정의된 메서드로 메서드가 정의된 위치에 직접 접근하여 사용한다. 함수와 비슷한 역활을 하며 메서드의 입력인자를 받고 내부에 코드 블럭을 실행하며 결과를 반활할 수 도 있다. 주로 콜백함수로 사용이 된다
    - 캡쳐
        - 외부변수를 캡처하여 사용할 수 있으며 캡처는 람다 내부에서 사용되는 외부 변수의 스냅샷을 만들어 제공합니다. **[&]**와 같이 캡처 기호를 사용하여 외부 변수를 참조로 캡처하거나, **[=]**와 같이 캡처 기호를 사용하여 외부 변수를 값으로 캡처할 수 있습니다.
    - 클로저:
        - 함수가 자신의 스코프 밖에서 정의된 변수에 접근할 수 있는 기능을 제공한다. 함수가 선언될 때 해당 함수 내부에서 사용되는 변수들은 클로저에 의해 캡저되어 저장되며, 이후에도 함수가 호출될 때 해당 변수들에 접근할 수 있다
    - LinQ
        - 자료구조들(컨테이너)을 SQL문법으로 다루는 것
- 파라미터 전달시 복사생정자 호출되지 않도록 하는방법
    - callbyadrees나 callbyreferance를 사용한다
- 벡터의 내적 외적 사용용도
    - 내적
        - 두백터의 내각을 알기위해 사용한다
        - cos세타, 범위는 -90~90
    - 외적
        - 내적의 범위는 앞뒤를 구분할 수 없으므로 내적을 사용한다
- 멀티스레드 문제
    - for문으로 전역변수 1000까지 합산을 했을 때 스레드 두개로 연산했을 시 결과가 2000이 안나오는 이유?(레이스컨디션 문제)
        - 레이스컨디션 때문에 발생하는데 이유는 한쪽이 연산이 완료되기 전에 다른 스레드가 침범하여 발생함(모든 멀티 프로그래밍에서 발생함)
    - 해결방법
        - 뮤텍스: 상호배제, 락킹이 존재, 정상적으로 완료가 되고 나와야 다른 스레드가 실행된다
        - 세마포어: 한 공간안에 같이 들어가는데 카운팅으로 조정을 해준다, 모니터 알고리즘
        - 프로세스는 뮤텍스 세마포어 둘다 똑같다

- 프로세스![](https://blog.kakaocdn.net/dn/bL3WRb/btstYbrdMjO/nY8r0wqtoLhKrw9NWQixJk/img.png)  
    - 정의 
        - 하나의 작업단위를 의미함(실행파일 하나)
        - RAM에 자기의 독립적인 메모리 공간을 하나를 가짐(즉 code,data,heap,stack영역 하나를 의미함)
        - 옛날의 싱글코어 시절에는 처리 시간을 빠르게하여 여러개의 프로그램이 동시에 실행되는 것 처럼 보여지게 해왔다
        - PCB라는 제어블록을 가진다
        - 프로세스 메모리 구역에는 다른 프로세스 메모리 구역이 침범할 수 없게 되어있는데 침범하게되면 그것이 해킹이다
    - IPC(Inter-Process Communication)
        - 정의
            - 프로세스가 여러개로 이 프로세스간에 통신이 가능해져야한다 하지만 프로세스간에 메모리구역은 통신이 불가능하므로 나오는 기술
        - 문제
            - I/O를 거쳐서 전달을 하므로 인터럽트가 발생해 속도가 느리다
    - 쓰레드 
        - IPC가 인터럽트를 발생해 속도가 느려 PCB를 모방해 TCB를 만들어낸게 쓰레드이다
        - 즉 프로세스를 모방해서 작은 단위로 만든것이다
        - 프로세스에있는메모리구역을 쓸뿐 자신의 메모리 구역을 따로 가지고있지 않고 쓰레들은 같은 메모리 위치에 존재한다
        - 함수단위로 일어난다
        - heap영역에 존재
    - 공유자원 문제 발생
        - 프로세스, 쓰레드 모두 발생함
        - 레시스컨디션
            - 한쪽이 연산이 완료되기 전에 다른 스레드가 침범을 해서 생긴다
    - 해결방안
        - 뮤텍스
            - 상호배제
            - 락킹이 존재
            - 정상적으로 완료가 되고 나와야 다른 스레드가 실행된다
        - 세마포어:
            - 한 공간안에 같이 들어가는데 카운팅으로 조정을 해준다
            - 모니터 알고리즘
        - 프로세스는 뮤텍스 세마포어 둘다 똑같다
    - 데드락
        
        - 멀티스레드나 멀티 프로세스 환경에서 발생하는 동기화 문제
        - 둘 이상의 작업 또는 스레드가 서로 상대방의 자원을 점유하고 기다리면서 무한히 진행이 멈추는 상태
        - 데드락을 해결하기 위해 4가지 조건중 하나 이상을 제거하거나 회피하는 방법을 사용하여야 한다
        - 상호베제, 점유와 대기, 비선점, 순환대기의 조건 중 하나를 균형적으로 처리하거나 조절해야한다
        
        1. 상호배제(Mutual Exclusion)
            1. 자원은 동시에 하나의 프로세스 또는 스레드에 의해서만 점유될 수 있으므로 다른 프로세스나 스레드가 해당 자원을 접근할 수 없다
        2. 점유와 대기(Hold and Wait)
            1. 프로세스나 스레드가 최소한 하나의 자원을 점유한 상태에서 다른 자원을 기다라고 있다 이때 이미점유한 자원을 놓지 않고 대기하고 있기 때문에 다른 프로세스나 스레드가 해장 자원을 사용할 수 없다
        3. 비선점(No Preemption)
            1. 이미 점유된 자원을 강제로 빼앗을 수 없다. 해당 자원을 사용하고 있는 프로세스나 스레드가 자발적으로 놓아주 않으면 다른 프로세스나 스레드는 접근이 불가하다
        4. 순환대기(Circular Wait)
            1. 두개이상의 프로세스나 스레드가 서로 원형으로 자원을 기다리는 상태로 상대방이 점유한 자원을 요청하면서 기다리고 있기 때문에 사이클이 형성되어 데드락이 발생한다
        
        - 예방방법
            - 상호베제 조건 제거
            - 점유와 대기조건 제거
            - 비선점 조건 제거
                - 이미 점유된 자원을 강제로 뺏기지 않게 해야한다
            - 순환대기 조건 제거
                - 고유 순서를 부여하여 순환 대기 상태를 방지한다